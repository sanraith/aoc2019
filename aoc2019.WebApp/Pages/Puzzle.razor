@using aoc2019.Puzzles
@using aoc2019.WebApp.Services
@inject ISolutionHandler SolutionHandler
@inject IInputHandler InputHandler
@page "/puzzle"
@page "/puzzle/{day}"

@if (SolutionMetadata == null)
{
    <h3>Puzzle @Day (no solution available)</h3>
}
else
{
    <h3>Puzzle @SolutionMetadata.Day</h3>

    if (Input == null)
    {
        <span>Loading input...</span>
    }
    else
    {
        <button @onclick="Solve">Solve</button>
        <br />
        foreach (var (result, number) in Results.Select((x, i) => (x, i + 1)))
        {
            <label for="part@(number)result">Part @(number)</label>
            <input name="part@(number)result" type="text" readonly value="@result" />
            <br />
        }

        @if (IsWorking)
        {
            <span>Calculating...</span>
            <br />
        }

        <h4>Input:</h4>
        <pre>@Input</pre>
    }
}

@code {
    [Parameter]
    public string Day { get; set; }

    private SolutionMetadata SolutionMetadata { get; set; }
    private string Input { get; set; }
    private List<string> Results { get; set; }
    private bool IsWorking { get; set; }

    protected override Task OnParametersSetAsync() => Init();

    private async Task Init()
    {
        SolutionMetadata = null;
        Input = null;
        Results = new List<string> { };
        if (int.TryParse(Day, out var dayNumber) && SolutionHandler.Solutions.TryGetValue(dayNumber, out var solutionMetadata))
        {
            SolutionMetadata = solutionMetadata;
            Input = await InputHandler.GetInputAsync(solutionMetadata.Day);
        }
    }

    private async Task Solve()
    {
        try
        {
            IsWorking = true;
            Results = new List<string>();
            var solution = SolutionMetadata.CreateInstance();
            StateHasChanged();
            Results.Add(await ExceptionToString(solution.Part1));
            StateHasChanged();
            Results.Add(await ExceptionToString(solution.Part2));
        }
        finally
        {
            IsWorking = false;
        }
    }

    private async Task<string> ExceptionToString(Func<string, Task<string>> func)
    {
        try
        {
            return await func(Input);
        }
        catch (Exception e)
        {
            return e.ToString();
        }
    }
}
