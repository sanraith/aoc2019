@using System.Threading
@using aoc2019.Puzzles
@using aoc2019.WebApp.Services
@inject ISolutionHandler SolutionHandler
@inject IInputHandler InputHandler
@page "/puzzle"
@page "/puzzle/{day}"

@if (SolutionMetadata == null)
{
    <h3>Puzzle @Day (no solution available)</h3>
}
else
{
    <h3>Puzzle @SolutionMetadata.Day</h3>

    if (Input == null)
    {
        <span>Loading input...</span>
    }
    else
    {
        <button @onclick="SolveAsync" disabled="@(IsWorking?"disabled":null)">@(IsWorking ? "Calculating..." : "Solve")</button>
        <button @onclick="Cancel" style="@(IsWorking ? null : "display:none")">Cancel</button>
        <br />
        foreach (var (result, number) in Results.Select((x, i) => (x, i + 1)))
        {
            <label for="part@(number)result">Part @(number):</label>
            switch (result)
            {
                case string text:
                    <input name="part@(number)result" type="text" readonly value="@result" />
                    break;
                case TaskCanceledException _:
                    <span>Canceled.</span>
                    break;
                case NotImplementedException _:
                    <span>Not implemented.</span>
                    break;
                case Exception exception:
                    <span>Error - @exception</span>
                    break;
                case null when IsWorking:
                    <span>Calculating...</span>
                    break;
                default:
                    <span>no result.</span>
                    break;
            }
            <br />
        }

        <h4>Input:</h4>
        <pre>@Input</pre>
    }
}

@code {
    [Parameter]
    public string Day { get; set; }

    private SolutionMetadata SolutionMetadata { get; set; }
    private string Input { get; set; }
    private object[] Results { get; set; }
    private bool IsWorking { get; set; }

    private CancellationTokenSource CancellationTokenSource;

    protected override Task OnParametersSetAsync() => Init();
    private void Cancel() => CancellationTokenSource?.Cancel(true);

    private async Task Init()
    {
        Cancel();
        SolutionMetadata = null;
        Input = null;
        Results = null;
        if (int.TryParse(Day, out var dayNumber) && SolutionHandler.Solutions.TryGetValue(dayNumber, out var solutionMetadata))
        {
            SolutionMetadata = solutionMetadata;
            Input = await InputHandler.GetInputAsync(SolutionMetadata.Day);
            Results = InputHandler.GetResults(SolutionMetadata.Day);
        }
    }

    private async Task SolveAsync()
    {
        CancellationTokenSource = new CancellationTokenSource();
        try
        {
            IsWorking = true;
            InputHandler.ClearResults(SolutionMetadata.Day);
            var solution = SolutionMetadata.CreateInstance();
            solution.CancellationToken = CancellationTokenSource.Token;

            foreach (var (part, index) in new Func<string, Task<string>>[] { solution.Part1, solution.Part2 }.Select((x, i) => (x, i)))
            {
                StateHasChanged();
                Results[index] = await ExceptionToResult(part);
            }
        }
        finally
        {
            IsWorking = false;
        }
    }

    private async Task<object> ExceptionToResult(Func<string, Task<string>> func)
    {
        try
        {
            return await (func(Input) ?? Task.FromResult<string>(null));
        }
        catch (Exception exception)
        {
            return exception;
        }
    }
}
